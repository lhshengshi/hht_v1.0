; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\bsp_usart2.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\bsp_usart2.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\Libraries\ST_Library\CMSIS\Include -I..\Libraries\ST_Library\CMSIS\Device\ST\STM32F4xx\Include -I..\Libraries\ST_Library\STM32F4xx_StdPeriph_Driver\inc -I..\User\User\Inc -I..\User\User_BSP -I..\User\User_BSP\BSP_Inc -I..\User\User_BSP\BSP_Usart2 -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\obj\bsp_usart2.crf ..\User\User_BSP\BSP_Usart2\BSP_Usart2.c]
                          THUMB

                          AREA ||i.USART2_Configuration||, CODE, READONLY, ALIGN=2

                  USART2_Configuration PROC
;;;32     /* Private functions -----------------------------------*/
;;;33     void USART2_Configuration(void)
000000  b500              PUSH     {lr}
;;;34     {
000002  b087              SUB      sp,sp,#0x1c
;;;35         USART_InitTypeDef USART_InitStruct;
;;;36         GPIO_InitTypeDef GPIO_InitStruct;
;;;37     
;;;38         RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;39         RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;40     
;;;41         GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
000014  2207              MOVS     r2,#7
000016  2102              MOVS     r1,#2
000018  481d              LDR      r0,|L1.144|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;42         GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
00001e  2207              MOVS     r2,#7
000020  2103              MOVS     r1,#3
000022  481b              LDR      r0,|L1.144|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;43     
;;;44         GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_2;
000028  200c              MOVS     r0,#0xc
00002a  9001              STR      r0,[sp,#4]
;;;45         GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
00002c  2002              MOVS     r0,#2
00002e  f88d0008          STRB     r0,[sp,#8]
;;;46         GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
000032  f88d0009          STRB     r0,[sp,#9]
;;;47         GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
000036  2000              MOVS     r0,#0
000038  f88d000a          STRB     r0,[sp,#0xa]
;;;48         GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
00003c  2001              MOVS     r0,#1
00003e  f88d000b          STRB     r0,[sp,#0xb]
;;;49         GPIO_Init(GPIOA, &GPIO_InitStruct);
000042  a901              ADD      r1,sp,#4
000044  4812              LDR      r0,|L1.144|
000046  f7fffffe          BL       GPIO_Init
;;;50     
;;;51         USART_InitStruct.USART_BaudRate = USART2_BaudRate;
00004a  f44f5016          MOV      r0,#0x2580
00004e  9003              STR      r0,[sp,#0xc]
;;;52         USART_InitStruct.USART_StopBits = USART_StopBits_1;
000050  2000              MOVS     r0,#0
000052  f8ad0012          STRH     r0,[sp,#0x12]
;;;53         USART_InitStruct.USART_WordLength = USART_WordLength_8b;
000056  f8ad0010          STRH     r0,[sp,#0x10]
;;;54         USART_InitStruct.USART_Parity = USART_Parity_No;
00005a  f8ad0014          STRH     r0,[sp,#0x14]
;;;55         USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005e  f8ad0018          STRH     r0,[sp,#0x18]
;;;56         USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
000062  200c              MOVS     r0,#0xc
000064  f8ad0016          STRH     r0,[sp,#0x16]
;;;57         USART_Init(USART2, &USART_InitStruct);
000068  a903              ADD      r1,sp,#0xc
00006a  480a              LDR      r0,|L1.148|
00006c  f7fffffe          BL       USART_Init
;;;58         USART_ITConfig(USART2,USART_IT_RXNE,DISABLE);//禁止接收中断
000070  2200              MOVS     r2,#0
000072  f2405125          MOV      r1,#0x525
000076  4807              LDR      r0,|L1.148|
000078  f7fffffe          BL       USART_ITConfig
;;;59         USART_Cmd(USART2, ENABLE);//使能串口2
00007c  2101              MOVS     r1,#1
00007e  4805              LDR      r0,|L1.148|
000080  f7fffffe          BL       USART_Cmd
;;;60         USART_ClearFlag(USART2, USART_FLAG_TC);
000084  2140              MOVS     r1,#0x40
000086  4803              LDR      r0,|L1.148|
000088  f7fffffe          BL       USART_ClearFlag
;;;61     }
00008c  b007              ADD      sp,sp,#0x1c
00008e  bd00              POP      {pc}
;;;62     
                          ENDP

                  |L1.144|
                          DCD      0x40020000
                  |L1.148|
                          DCD      0x40004400

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;65     //串口2中断服务程序
;;;66     void USART2_IRQHandler(void)                	
000000  b510              PUSH     {r4,lr}
;;;67     {
;;;68         u8 Res = Res;
000002  bf00              NOP      
;;;69         if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000004  f2405125          MOV      r1,#0x525
000008  4821              LDR      r0,|L2.144|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b368              CBZ      r0,|L2.108|
;;;70         {
;;;71             Res = USART_ReceiveData(USART2);//(USART1->DR);	//读取接收到的数据
000010  481f              LDR      r0,|L2.144|
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c4              UXTB     r4,r0
;;;72     		if(Usart2_RxFlag > 100)//数据溢出，默认接受失败
000018  481e              LDR      r0,|L2.148|
00001a  7800              LDRB     r0,[r0,#0]  ; Usart2_RxFlag
00001c  2864              CMP      r0,#0x64
00001e  dd04              BLE      |L2.42|
;;;73     		{
;;;74     		    Usart2_RxFlag = FALSE ;
000020  2000              MOVS     r0,#0
000022  491c              LDR      r1,|L2.148|
000024  7008              STRB     r0,[r1,#0]
;;;75     			Usart2_Rx_Finish = FALSE;
000026  491c              LDR      r1,|L2.152|
000028  7008              STRB     r0,[r1,#0]
                  |L2.42|
;;;76     		}
;;;77     		if((Usart2_RxFlag > FALSE)&&(Usart2_Rx_Finish != TRUE))
00002a  481a              LDR      r0,|L2.148|
00002c  7800              LDRB     r0,[r0,#0]  ; Usart2_RxFlag
00002e  2800              CMP      r0,#0
000030  dd0c              BLE      |L2.76|
000032  4819              LDR      r0,|L2.152|
000034  7800              LDRB     r0,[r0,#0]  ; Usart2_Rx_Finish
000036  2801              CMP      r0,#1
000038  d008              BEQ      |L2.76|
;;;78     		{
;;;79     			Usart2_RxBuf[Usart2_RxFlag++] =Res;	
00003a  4816              LDR      r0,|L2.148|
00003c  7801              LDRB     r1,[r0,#0]  ; Usart2_RxFlag
00003e  7800              LDRB     r0,[r0,#0]  ; Usart2_RxFlag
000040  1c40              ADDS     r0,r0,#1
000042  4a14              LDR      r2,|L2.148|
000044  7010              STRB     r0,[r2,#0]
000046  4815              LDR      r0,|L2.156|
000048  5444              STRB     r4,[r0,r1]
00004a  e020              B        |L2.142|
                  |L2.76|
;;;80     		}
;;;81     		else if((Usart2_RxFlag == FALSE)&&((Usart2_Rx_Finish != TRUE)))
00004c  4811              LDR      r0,|L2.148|
00004e  7800              LDRB     r0,[r0,#0]  ; Usart2_RxFlag
000050  b9e8              CBNZ     r0,|L2.142|
000052  4811              LDR      r0,|L2.152|
000054  7800              LDRB     r0,[r0,#0]  ; Usart2_Rx_Finish
000056  2801              CMP      r0,#1
000058  d019              BEQ      |L2.142|
;;;82     		{
;;;83     			Usart2_RxBuf[Usart2_RxFlag++] =Res;
00005a  480e              LDR      r0,|L2.148|
00005c  7801              LDRB     r1,[r0,#0]  ; Usart2_RxFlag
00005e  7800              LDRB     r0,[r0,#0]  ; Usart2_RxFlag
000060  1c40              ADDS     r0,r0,#1
000062  4a0c              LDR      r2,|L2.148|
000064  7010              STRB     r0,[r2,#0]
000066  480d              LDR      r0,|L2.156|
000068  5444              STRB     r4,[r0,r1]
00006a  e010              B        |L2.142|
                  |L2.108|
;;;84     		}	
;;;85         }
;;;86         else if(USART_GetITStatus(USART2, USART_IT_IDLE) != RESET)
00006c  f2404124          MOV      r1,#0x424
000070  4807              LDR      r0,|L2.144|
000072  f7fffffe          BL       USART_GetITStatus
000076  b150              CBZ      r0,|L2.142|
;;;87         {
;;;88             USART2->SR;//先读SR，DR目的为了清除USART_IT_IDLE中断
000078  4805              LDR      r0,|L2.144|
00007a  8800              LDRH     r0,[r0,#0]
;;;89             USART2->DR;
00007c  4804              LDR      r0,|L2.144|
00007e  1d00              ADDS     r0,r0,#4
000080  8800              LDRH     r0,[r0,#0]
;;;90     		Usart2_RxFlag = FALSE;
000082  2000              MOVS     r0,#0
000084  4903              LDR      r1,|L2.148|
000086  7008              STRB     r0,[r1,#0]
;;;91             Usart2_Rx_Finish = TRUE;
000088  2001              MOVS     r0,#1
00008a  4903              LDR      r1,|L2.152|
00008c  7008              STRB     r0,[r1,#0]
                  |L2.142|
;;;92         }
;;;93     }
00008e  bd10              POP      {r4,pc}
;;;94     //RS485 发送函数
                          ENDP

                  |L2.144|
                          DCD      0x40004400
                  |L2.148|
                          DCD      Usart2_RxFlag
                  |L2.152|
                          DCD      Usart2_Rx_Finish
                  |L2.156|
                          DCD      Usart2_RxBuf

                          AREA ||i.Usart2SendStr||, CODE, READONLY, ALIGN=2

                  Usart2SendStr PROC
;;;94     //RS485 发送函数
;;;95      u8 Usart2SendStr(u8 *str,u16 strlen)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;97     	for(u8 i=0;i<strlen;i++)
000006  2400              MOVS     r4,#0
000008  e00c              B        |L3.36|
                  |L3.10|
;;;98     	{
;;;99     		USART_SendData(USART2,*(str+i));
00000a  5d29              LDRB     r1,[r5,r4]
00000c  4809              LDR      r0,|L3.52|
00000e  f7fffffe          BL       USART_SendData
;;;100    		/* Loop until the end of transmission */
;;;101    		while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
000012  bf00              NOP      
                  |L3.20|
000014  2180              MOVS     r1,#0x80
000016  4807              LDR      r0,|L3.52|
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L3.20|
000020  1c60              ADDS     r0,r4,#1              ;97
000022  b2c4              UXTB     r4,r0                 ;97
                  |L3.36|
000024  42b4              CMP      r4,r6                 ;97
000026  dbf0              BLT      |L3.10|
;;;102    	}
;;;103        Delay_us(1000);//延时小了最后一个字节发送不出去，最少延时一个字节的时间
000028  f44f707a          MOV      r0,#0x3e8
00002c  f7fffffe          BL       Delay_us
;;;104    	return TRUE;
000030  2001              MOVS     r0,#1
;;;105    }
000032  bd70              POP      {r4-r6,pc}
;;;106    
                          ENDP

                  |L3.52|
                          DCD      0x40004400

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;106    
;;;107    PUTCHAR_PROTOTYPE
000000  b570              PUSH     {r4-r6,lr}
;;;108    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;109        /* Place your implementation of fputc here */
;;;110        /* e.g. write a character to the USART */
;;;111        USART_SendData(USART2,(uint8_t)ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L4.32|
00000a  f7fffffe          BL       USART_SendData
;;;112    
;;;113        /* Loop until the end of transmission */
;;;114        while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
00000e  bf00              NOP      
                  |L4.16|
000010  2180              MOVS     r1,#0x80
000012  4803              LDR      r0,|L4.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L4.16|
;;;115    
;;;116        return ch;
00001c  4620              MOV      r0,r4
;;;117    }
00001e  bd70              POP      {r4-r6,pc}
;;;118    /********** (C) COPYRIGHT DIY嵌入式开发工作室 （END OF FILE ）************************/
                          ENDP

                  |L4.32|
                          DCD      0x40004400

                          AREA ||.data||, DATA, ALIGN=0

                  Usart2_RxFlag
000000  00                DCB      0x00
                  Usart2_Rx_Finish
000001  00                DCB      0x00
                  Usart2_RxBuf
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000
000008  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\User_BSP\\BSP_Usart2\\BSP_Usart2.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_BSP_Usart2_c_fd9ee9f7____REV16|
#line 129 "..\\Libraries\\ST_Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_BSP_Usart2_c_fd9ee9f7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_BSP_Usart2_c_fd9ee9f7____REVSH|
#line 144
|__asm___12_BSP_Usart2_c_fd9ee9f7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_BSP_Usart2_c_fd9ee9f7____RRX|
#line 300
|__asm___12_BSP_Usart2_c_fd9ee9f7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
