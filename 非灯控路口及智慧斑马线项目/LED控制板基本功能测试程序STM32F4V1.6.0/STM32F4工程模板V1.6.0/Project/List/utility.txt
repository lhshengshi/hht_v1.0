; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\utility.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\utility.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\Libraries\ST_Library\CMSIS\Include -I..\Libraries\ST_Library\CMSIS\Device\ST\STM32F4xx\Include -I..\Libraries\ST_Library\STM32F4xx_StdPeriph_Driver\inc -I..\User\User\Inc -I..\User\User_BSP -I..\User\User_BSP\BSP_Inc -I..\User\User_BSP\BSP_Usart2 -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\obj\utility.crf ..\User\User\Src\Utility.c]
                          THUMB

                          AREA ||i.BCDToChar||, CODE, READONLY, ALIGN=1

                  BCDToChar PROC
;;;416    */
;;;417    char BCDToChar(unsigned char c	)
000000  4601              MOV      r1,r0
;;;418    {
;;;419    	return (char)((c>>4)&0X0F)*10+(c&0x0F);
000002  f001000f          AND      r0,r1,#0xf
000006  090a              LSRS     r2,r1,#4
000008  eb020282          ADD      r2,r2,r2,LSL #2
00000c  eb000042          ADD      r0,r0,r2,LSL #1
000010  b2c0              UXTB     r0,r0
;;;420    }
000012  4770              BX       lr
;;;421    /**
                          ENDP


                          AREA ||i.BSP_InitDWT||, CODE, READONLY, ALIGN=2

                  BSP_InitDWT PROC
;;;106    ***********************************/
;;;107    void BSP_InitDWT(void)
000000  4807              LDR      r0,|L2.32|
;;;108    {
;;;109    	DEM_CR         |= (unsigned int)DEM_CR_TRCENA;   /* Enable Cortex-M4's DWT CYCCNT reg.  */
000002  6800              LDR      r0,[r0,#0]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4905              LDR      r1,|L2.32|
00000a  6008              STR      r0,[r1,#0]
;;;110    	DWT_CYCCNT      = (unsigned int)0u;
00000c  2000              MOVS     r0,#0
00000e  4905              LDR      r1,|L2.36|
000010  6048              STR      r0,[r1,#4]
;;;111    	DWT_CR         |= (unsigned int)DWT_CR_CYCCNTENA;
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  f0400001          ORR      r0,r0,#1
00001a  6008              STR      r0,[r1,#0]
;;;112    }
00001c  4770              BX       lr
;;;113    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0xe000edfc
                  |L2.36|
                          DCD      0xe0001000

                          AREA ||i.C2D||, CODE, READONLY, ALIGN=1

                  ||C2D|| PROC
;;;375    */
;;;376    char C2D(unsigned char c	)
000000  4601              MOV      r1,r0
;;;377    {
;;;378    	if (c >= '0' && c <= '9')
000002  2930              CMP      r1,#0x30
000004  db05              BLT      |L3.18|
000006  2939              CMP      r1,#0x39
000008  dc03              BGT      |L3.18|
;;;379    		return c - '0';
00000a  f1a10030          SUB      r0,r1,#0x30
00000e  b2c0              UXTB     r0,r0
                  |L3.16|
;;;380    	if (c >= 'a' && c <= 'f')
;;;381    		return 10 + c -'a';
;;;382    	if (c >= 'A' && c <= 'F')
;;;383    		return 10 + c -'A';
;;;384    
;;;385    	return (char)c;
;;;386    }
000010  4770              BX       lr
                  |L3.18|
000012  2961              CMP      r1,#0x61              ;380
000014  db05              BLT      |L3.34|
000016  2966              CMP      r1,#0x66              ;380
000018  dc03              BGT      |L3.34|
00001a  f1a10057          SUB      r0,r1,#0x57           ;381
00001e  b2c0              UXTB     r0,r0                 ;381
000020  e7f6              B        |L3.16|
                  |L3.34|
000022  2941              CMP      r1,#0x41              ;382
000024  db05              BLT      |L3.50|
000026  2946              CMP      r1,#0x46              ;382
000028  dc03              BGT      |L3.50|
00002a  f1a10037          SUB      r0,r1,#0x37           ;383
00002e  b2c0              UXTB     r0,r0                 ;383
000030  e7ee              B        |L3.16|
                  |L3.50|
000032  4608              MOV      r0,r1                 ;385
000034  e7ec              B        |L3.16|
;;;387    ///**
                          ENDP


                          AREA ||i.Caculate_CRC8_Byte||, CODE, READONLY, ALIGN=1

                  Caculate_CRC8_Byte PROC
;;;303    *******************************************************************************/
;;;304    static uint8_t Caculate_CRC8_Byte(uint8_t abyte)
000000  4601              MOV      r1,r0
;;;305    {
;;;306       uint8_t i,crc_1byte;
;;;307    
;;;308    	crc_1byte=0;                //设定crc_1byte初值为0
000002  2000              MOVS     r0,#0
;;;309    	for(i = 0; i < 8; i++)
000004  2200              MOVS     r2,#0
000006  e00e              B        |L4.38|
                  |L4.8|
;;;310    	{
;;;311    		if(((crc_1byte^abyte)&0x01))
000008  ea800301          EOR      r3,r0,r1
00000c  f0030301          AND      r3,r3,#1
000010  b12b              CBZ      r3,|L4.30|
;;;312    		{
;;;313    			crc_1byte^=0x18;
000012  f0800018          EOR      r0,r0,#0x18
;;;314    			crc_1byte>>=1;
000016  1040              ASRS     r0,r0,#1
;;;315    			crc_1byte|=0x80;
000018  f0400080          ORR      r0,r0,#0x80
00001c  e000              B        |L4.32|
                  |L4.30|
;;;316    		}
;;;317    		else
;;;318    		{
;;;319    			crc_1byte>>=1;
00001e  1040              ASRS     r0,r0,#1
                  |L4.32|
;;;320    		}
;;;321    		abyte>>=1;
000020  1049              ASRS     r1,r1,#1
000022  1c53              ADDS     r3,r2,#1              ;309
000024  b2da              UXTB     r2,r3                 ;309
                  |L4.38|
000026  2a08              CMP      r2,#8                 ;309
000028  dbee              BLT      |L4.8|
;;;322    	}
;;;323    	return crc_1byte;
;;;324    }
00002a  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.CharToBCD||, CODE, READONLY, ALIGN=1

                  CharToBCD PROC
;;;407    */
;;;408    char CharToBCD(unsigned char c	)
000000  4601              MOV      r1,r0
;;;409    {
;;;410    	return (char)((c/10<<4)+(c%10));
000002  200a              MOVS     r0,#0xa
000004  fb91f2f0          SDIV     r2,r1,r0
000008  fb001012          MLS      r0,r0,r2,r1
00000c  220a              MOVS     r2,#0xa
00000e  fb91f2f2          SDIV     r2,r1,r2
000012  eb001002          ADD      r0,r0,r2,LSL #4
000016  b2c0              UXTB     r0,r0
;;;411    }
000018  4770              BX       lr
;;;412    /**
                          ENDP


                          AREA ||i.Delay_Init||, CODE, READONLY, ALIGN=2

                  Delay_Init PROC
;;;118    //SYSCLK:系统时钟
;;;119    void Delay_Init(u8 SYSCLK)
000000  b510              PUSH     {r4,lr}
;;;120    {
000002  4604              MOV      r4,r0
;;;121     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);
000004  f06f0004          MVN      r0,#4
000008  f7fffffe          BL       SysTick_CLKSourceConfig
;;;122    	fac_us=SYSCLK/8;		//不论是否使用ucos,fac_us都需要使用
00000c  17e1              ASRS     r1,r4,#31
00000e  eb047151          ADD      r1,r4,r1,LSR #29
000012  f3c101c7          UBFX     r1,r1,#3,#8
000016  4a07              LDR      r2,|L6.52|
000018  7011              STRB     r1,[r2,#0]
;;;123    	fac_ms=(u16)fac_us*1000;//非ucos下,代表每个ms需要的systick时钟数   
00001a  4610              MOV      r0,r2
00001c  7800              LDRB     r0,[r0,#0]  ; fac_us
00001e  eb000140          ADD      r1,r0,r0,LSL #1
000022  ebc110c0          RSB      r0,r1,r0,LSL #7
000026  f64f71ff          MOV      r1,#0xffff
00002a  ea0100c0          AND      r0,r1,r0,LSL #3
00002e  4902              LDR      r1,|L6.56|
000030  8008              STRH     r0,[r1,#0]
;;;124    }								    
000032  bd10              POP      {r4,pc}
;;;125    //延时nus
                          ENDP

                  |L6.52|
                          DCD      fac_us
                  |L6.56|
                          DCD      fac_ms

                          AREA ||i.Delay_ms||, CODE, READONLY, ALIGN=1

                  Delay_ms PROC
;;;163    //nms:0~65535
;;;164    void Delay_ms(u16 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {	 	 
000002  4604              MOV      r4,r0
;;;166    	u8 repeat=nms/540;	//这里用540,是考虑到某些客户可能超频使用,
000004  f44f7007          MOV      r0,#0x21c
000008  fb94f0f0          SDIV     r0,r4,r0
00000c  b2c6              UXTB     r6,r0
;;;167    						//比如超频到248M的时候,delay_xms最大只能延时541ms左右了
;;;168    	u16 remain=nms%540;
00000e  f44f7007          MOV      r0,#0x21c
000012  fb94f1f0          SDIV     r1,r4,r0
000016  fb004011          MLS      r0,r0,r1,r4
00001a  b285              UXTH     r5,r0
;;;169    	while(repeat)
00001c  e005              B        |L7.42|
                  |L7.30|
;;;170    	{
;;;171    		Delay_xms(540);
00001e  f44f7007          MOV      r0,#0x21c
000022  f7fffffe          BL       Delay_xms
;;;172    		repeat--;
000026  1e70              SUBS     r0,r6,#1
000028  b2c6              UXTB     r6,r0
                  |L7.42|
00002a  2e00              CMP      r6,#0                 ;169
00002c  d1f7              BNE      |L7.30|
;;;173    	}
;;;174    	if(remain)Delay_xms(remain);
00002e  b115              CBZ      r5,|L7.54|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       Delay_xms
                  |L7.54|
;;;175    	
;;;176    } 
000036  bd70              POP      {r4-r6,pc}
;;;177    
                          ENDP


                          AREA ||i.Delay_us||, CODE, READONLY, ALIGN=2

                  Delay_us PROC
;;;127    //注意:nus的值,不要大于798915us
;;;128    void Delay_us(u32 nus)
000000  4601              MOV      r1,r0
;;;129    {		
;;;130    	u32 temp;	    	 
;;;131    	SysTick->LOAD=nus*fac_us; //时间加载	  		 
000002  4a11              LDR      r2,|L8.72|
000004  7812              LDRB     r2,[r2,#0]  ; fac_us
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;132    	SysTick->VAL=0x00;        //清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;133    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;          //开始倒数 
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;134    	do
00001c  bf00              NOP      
                  |L8.30|
;;;135    	{
;;;136    		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;137    	}
;;;138    	while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L8.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L8.30|
                  |L8.50|
;;;139    	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;       //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;140    	SysTick->VAL =0X00;       //清空计数器	 
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;141    }
000046  4770              BX       lr
;;;142    //延时nms
                          ENDP

                  |L8.72|
                          DCD      fac_us

                          AREA ||i.Delay_xms||, CODE, READONLY, ALIGN=2

                  Delay_xms PROC
;;;147    //对168M条件下,nms<=798ms 
;;;148    static void Delay_xms(u16 nms)
000000  4601              MOV      r1,r0
;;;149    {	 		  	  
;;;150    	u32 temp;		   
;;;151    	SysTick->LOAD=(u32)nms*fac_ms;//时间加载(SysTick->LOAD为24bit)
000002  4a11              LDR      r2,|L9.72|
000004  8812              LDRH     r2,[r2,#0]  ; fac_ms
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;152    	SysTick->VAL =0x00;           //清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;153    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;          //开始倒数  
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;154    	do
00001c  bf00              NOP      
                  |L9.30|
;;;155    	{
;;;156    		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;157    	}
;;;158    	while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L9.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L9.30|
                  |L9.50|
;;;159    	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;       //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;160    	SysTick->VAL =0X00;       //清空计数器	  	    
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;161    } 
000046  4770              BX       lr
;;;162    //延时nms 
                          ENDP

                  |L9.72|
                          DCD      fac_ms

                          AREA ||i.Get_ChipID||, CODE, READONLY, ALIGN=2

                  Get_ChipID PROC
;;;185    */
;;;186    void Get_ChipID(void)
000000  4806              LDR      r0,|L10.28|
;;;187    {
;;;188    #if 1    
;;;189         //地址从小到大,先放低字节，再放高字节：小端模式
;;;190         //地址从小到大,先放高字节，再放低字节：大端模式
;;;191     ChipUniqueID[2] = *(__IO u32*)(0X1FFFF7E8);  // 低字节
000002  6800              LDR      r0,[r0,#0]
000004  4906              LDR      r1,|L10.32|
000006  6088              STR      r0,[r1,#8]  ; ChipUniqueID
;;;192     ChipUniqueID[1] = *(__IO u32 *)(0X1FFFF7EC); // 
000008  4804              LDR      r0,|L10.28|
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
00000e  6048              STR      r0,[r1,#4]  ; ChipUniqueID
;;;193     ChipUniqueID[0] = *(__IO u32 *)(0X1FFFF7F0); // 高字节
000010  4802              LDR      r0,|L10.28|
000012  3008              ADDS     r0,r0,#8
000014  6800              LDR      r0,[r0,#0]
000016  6008              STR      r0,[r1,#0]  ; ChipUniqueID
;;;194    // printf("######## 芯片的唯一ID为: X-X-X  rn",ChipUniqueID[0],ChipUniqueID[1],ChipUniqueID[2]);
;;;195              //此条语句输出32位
;;;196    #else   //调整了大小端模式，与ISP下载软件的一致
;;;197        u8 temp[12];   
;;;198        u32 temp0,temp1,temp2;
;;;199        temp0=*(__IO u32*)(0x1FFFF7E8);    //产品唯一身份标识寄存器（96位）
;;;200        temp1=*(__IO u32*)(0x1FFFF7EC);
;;;201        temp2=*(__IO u32*)(0x1FFFF7F0);
;;;202        temp[0] = (u8)(temp0 & 0x000000FF);
;;;203        temp[1] = (u8)((temp0 & 0x0000FF00)>>8);
;;;204        temp[2] = (u8)((temp0 & 0x00FF0000)>>16);
;;;205        temp[3] = (u8)((temp0 & 0xFF000000)>>24);
;;;206        temp[4] = (u8)(temp1 & 0x000000FF);
;;;207        temp[5] = (u8)((temp1 & 0x0000FF00)>>8);
;;;208        temp[6] = (u8)((temp1 & 0x00FF0000)>>16);
;;;209        temp[7] = (u8)((temp1 & 0xFF000000)>>24);
;;;210        temp[8] = (u8)(temp2 & 0x000000FF);
;;;211        temp[9] = (u8)((temp2 & 0x0000FF00)>>8);
;;;212        temp[10] = (u8)((temp2 & 0x00FF0000)>>16);
;;;213        temp[11] = (u8)((temp2 & 0xFF000000)>>24);
;;;214    //    printf("######## STM32芯片ID为: %.2X%.2X%.2X%.2X-%.2X%.2X%.2X%.2X-%.2X%.2X%.2X%.2X rn",
;;;215    //  temp[0],temp[1],temp[2],temp[3],temp[4],temp[5],temp[6],temp[7],temp[8],temp[9],temp[10],temp [11]); //串口打印出芯片ID
;;;216    #endif
;;;217    }
000018  4770              BX       lr
;;;218    /*
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x1ffff7e8
                  |L10.32|
                          DCD      ChipUniqueID

                          AREA ||i.Get_ChipInfo||, CODE, READONLY, ALIGN=2

                  Get_ChipInfo PROC
;;;224    */
;;;225    void Get_ChipInfo(void)
000000  4808              LDR      r0,|L11.36|
;;;226    {
;;;227       ChipUniqueID[0] = *(__IO u32 *)(0X1FFF7A10); // 高字节
000002  6800              LDR      r0,[r0,#0]
000004  4908              LDR      r1,|L11.40|
000006  6008              STR      r0,[r1,#0]  ; ChipUniqueID
;;;228       ChipUniqueID[1] = *(__IO u32 *)(0X1FFF7A14); //
000008  4806              LDR      r0,|L11.36|
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
00000e  6048              STR      r0,[r1,#4]  ; ChipUniqueID
;;;229       ChipUniqueID[2] = *(__IO u32 *)(0X1FFF7A18); // 低字节
000010  4804              LDR      r0,|L11.36|
000012  3008              ADDS     r0,r0,#8
000014  6800              LDR      r0,[r0,#0]
000016  6088              STR      r0,[r1,#8]  ; ChipUniqueID
;;;230       STM32_FLASH_SIZE= *(u16*)(0x1FFFF7E0);    //闪存容量寄存器  
000018  4804              LDR      r0,|L11.44|
00001a  8800              LDRH     r0,[r0,#0]
00001c  4904              LDR      r1,|L11.48|
00001e  8008              STRH     r0,[r1,#0]
;;;231    //   printf("rn########### 芯片的唯一ID为: %X-%X-%X n",
;;;232    //           ChipUniqueID[0],ChipUniqueID[1],ChipUniqueID[2]);  
;;;233    //   printf("rn########### 芯片flash的容量为: %dK n", STM32_FLASH_SIZE);
;;;234    //   printf("rn########### 烧录日期: "__DATE__" - "__TIME__"n");
;;;235          //输出使用固件库版本号 
;;;236    }
000020  4770              BX       lr
;;;237    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      0x1fff7a10
                  |L11.40|
                          DCD      ChipUniqueID
                  |L11.44|
                          DCD      0x1ffff7e0
                  |L11.48|
                          DCD      STM32_FLASH_SIZE

                          AREA ||i.StrCmp||, CODE, READONLY, ALIGN=1

                  StrCmp PROC
;;;543    //两个数组比较
;;;544    uint8_t StrCmp(uint8_t *str1,uint8_t *str2,uint16_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;545    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;546        for(uint16_t i=0;i<len;i++)
000006  2100              MOVS     r1,#0
000008  e007              B        |L12.26|
                  |L12.10|
;;;547    	{
;;;548    	   if(*(str1+i) == *(str2+i));
00000a  5c58              LDRB     r0,[r3,r1]
00000c  5c65              LDRB     r5,[r4,r1]
00000e  42a8              CMP      r0,r5
000010  d001              BEQ      |L12.22|
;;;549    	   else return FALSE;
000012  2000              MOVS     r0,#0
                  |L12.20|
;;;550    	}
;;;551    	return TRUE;
;;;552    }
000014  bd30              POP      {r4,r5,pc}
                  |L12.22|
000016  1c48              ADDS     r0,r1,#1              ;546
000018  b281              UXTH     r1,r0                 ;546
                  |L12.26|
00001a  4291              CMP      r1,r2                 ;546
00001c  dbf5              BLT      |L12.10|
00001e  2001              MOVS     r0,#1                 ;551
000020  e7f8              B        |L12.20|
;;;553    /* Private functions -----------------------------------*/
                          ENDP


                          AREA ||i.XORValid||, CODE, READONLY, ALIGN=1

                  XORValid PROC
;;;531    //异或校验
;;;532    uint8_t XORValid(uint8_t *buffer,uint16_t Len)
000000  b510              PUSH     {r4,lr}
;;;533    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;534        uint8_t checksum = 0;
000006  2000              MOVS     r0,#0
;;;535    	uint8_t i;
;;;536        for (i = 0;  i<Len;  i++)
000008  2100              MOVS     r1,#0
00000a  e003              B        |L13.20|
                  |L13.12|
;;;537        {
;;;538            checksum = checksum ^ buffer[i]; //进行异或交验取值
00000c  5c54              LDRB     r4,[r2,r1]
00000e  4060              EORS     r0,r0,r4
000010  1c4c              ADDS     r4,r1,#1              ;536
000012  b2e1              UXTB     r1,r4                 ;536
                  |L13.20|
000014  4299              CMP      r1,r3                 ;536
000016  dbf9              BLT      |L13.12|
;;;539    	}
;;;540    	return(checksum);
;;;541    }
000018  bd10              POP      {r4,pc}
;;;542    
                          ENDP


                          AREA ||i.atoi16||, CODE, READONLY, ALIGN=1

                  atoi16 PROC
;;;444    */
;;;445    uint16_t atoi16(char* str,uint16_t base	)
000000  b530              PUSH     {r4,r5,lr}
;;;446    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;447      unsigned int num = 0;
000006  2400              MOVS     r4,#0
;;;448      while (*str !=0)
000008  e005              B        |L14.22|
                  |L14.10|
;;;449              num = num * base + C2D(*str++);
00000a  f8120b01          LDRB     r0,[r2],#1
00000e  f7fffffe          BL       ||C2D||
000012  fb040403          MLA      r4,r4,r3,r0
                  |L14.22|
000016  7810              LDRB     r0,[r2,#0]            ;448
000018  2800              CMP      r0,#0                 ;448
00001a  d1f6              BNE      |L14.10|
;;;450      return num;
00001c  b2a0              UXTH     r0,r4
;;;451    }
00001e  bd30              POP      {r4,r5,pc}
;;;452    
                          ENDP


                          AREA ||i.checkCRC16||, CODE, READONLY, ALIGN=1

                  checkCRC16 PROC
;;;266    *******************************************************************************/
;;;267    uint8_t checkCRC16(uint8_t *msg, const uint16_t msg_length, uint8_t overturn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;268    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;269        uint16_t  crc_calc;
;;;270        uint16_t crc_received;
;;;271    
;;;272        if(msg_length < 3)
00000a  2c03              CMP      r4,#3
00000c  da02              BGE      |L15.20|
;;;273        {
;;;274            return 1;
00000e  2001              MOVS     r0,#1
                  |L15.16|
;;;275        }
;;;276    
;;;277        crc_calc = getCRC16(msg, msg_length - 2);
;;;278        if(overturn)
;;;279        {
;;;280            crc_received = (msg[msg_length - 1] << 8) | msg[msg_length - 2]; //接受数据时,先收到低字节,再是高字节.
;;;281        }else
;;;282        {
;;;283            crc_received = (msg[msg_length - 2] << 8) | msg[msg_length - 1];
;;;284        }
;;;285    
;;;286        /* Check CRC of msg */
;;;287        if (crc_calc == crc_received)
;;;288        {
;;;289            return 1;
;;;290        }
;;;291        else
;;;292        {
;;;293            return 0;
;;;294        }
;;;295    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L15.20|
000014  1ea0              SUBS     r0,r4,#2              ;277
000016  b281              UXTH     r1,r0                 ;277
000018  4628              MOV      r0,r5                 ;277
00001a  f7fffffe          BL       getCRC16
00001e  4606              MOV      r6,r0                 ;277
000020  f1b80f00          CMP      r8,#0                 ;278
000024  d006              BEQ      |L15.52|
000026  1ea0              SUBS     r0,r4,#2              ;280
000028  5c29              LDRB     r1,[r5,r0]            ;280
00002a  1e60              SUBS     r0,r4,#1              ;280
00002c  5c28              LDRB     r0,[r5,r0]            ;280
00002e  ea412700          ORR      r7,r1,r0,LSL #8       ;280
000032  e005              B        |L15.64|
                  |L15.52|
000034  1e60              SUBS     r0,r4,#1              ;283
000036  5c29              LDRB     r1,[r5,r0]            ;283
000038  1ea0              SUBS     r0,r4,#2              ;283
00003a  5c28              LDRB     r0,[r5,r0]            ;283
00003c  ea412700          ORR      r7,r1,r0,LSL #8       ;283
                  |L15.64|
000040  42be              CMP      r6,r7                 ;287
000042  d101              BNE      |L15.72|
000044  2001              MOVS     r0,#1                 ;289
000046  e7e3              B        |L15.16|
                  |L15.72|
000048  2000              MOVS     r0,#0                 ;293
00004a  e7e1              B        |L15.16|
;;;296    
                          ENDP


                          AREA ||i.checkCRC8||, CODE, READONLY, ALIGN=1

                  checkCRC8 PROC
;;;352    *******************************************************************************/
;;;353    uint8_t checkCRC8(uint8_t *pbuf,uint8_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;354    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;355        uint8_t crc=0,i;
000008  2600              MOVS     r6,#0
;;;356    
;;;357        for(i=0;i<len;i++)
00000a  2700              MOVS     r7,#0
00000c  e008              B        |L16.32|
                  |L16.14|
;;;358        {
;;;359            crc = Caculate_CRC8_Byte(crc^*pbuf++);
00000e  f8141b01          LDRB     r1,[r4],#1
000012  ea810006          EOR      r0,r1,r6
000016  f7fffffe          BL       Caculate_CRC8_Byte
00001a  4606              MOV      r6,r0
00001c  1c78              ADDS     r0,r7,#1              ;357
00001e  b2c7              UXTB     r7,r0                 ;357
                  |L16.32|
000020  42af              CMP      r7,r5                 ;357
000022  dbf4              BLT      |L16.14|
;;;360        }
;;;361        if(crc == 0)
000024  b916              CBNZ     r6,|L16.44|
;;;362        {
;;;363            return 1;
000026  2001              MOVS     r0,#1
                  |L16.40|
;;;364        }else 
;;;365        {   
;;;366            return 0;
;;;367        }
;;;368    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L16.44|
00002c  2000              MOVS     r0,#0                 ;366
00002e  e7fb              B        |L16.40|
;;;369    
                          ENDP


                          AREA ||i.getCRC16||, CODE, READONLY, ALIGN=2

                  getCRC16 PROC
;;;239    //返回的CRC校验结果,高低位未互换
;;;240    uint16_t getCRC16(uint8_t *buffer, uint16_t buffer_length)
000000  b570              PUSH     {r4-r6,lr}
;;;241    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;242        uint8_t crc_hi = 0xFF; /* high CRC byte initialized */
000006  25ff              MOVS     r5,#0xff
;;;243        uint8_t crc_lo = 0xFF; /* low CRC byte initialized */
000008  23ff              MOVS     r3,#0xff
;;;244        unsigned int i; /* will index into CRC lookup */
;;;245    
;;;246        /* pass through message buffer */
;;;247        while (buffer_length--)
00000a  e009              B        |L17.32|
                  |L17.12|
;;;248        {
;;;249            i = crc_hi ^ *buffer++; /* calculate the CRC  */
00000c  f8120b01          LDRB     r0,[r2],#1
000010  ea800105          EOR      r1,r0,r5
;;;250            crc_hi = crc_lo ^ table_crc_hi[i];
000014  4806              LDR      r0,|L17.48|
000016  5c40              LDRB     r0,[r0,r1]
000018  ea800503          EOR      r5,r0,r3
;;;251            crc_lo = table_crc_lo[i];
00001c  4805              LDR      r0,|L17.52|
00001e  5c43              LDRB     r3,[r0,r1]
                  |L17.32|
000020  0020              MOVS     r0,r4                 ;247
000022  f1a40601          SUB      r6,r4,#1              ;247
000026  b2b4              UXTH     r4,r6                 ;247
000028  d1f0              BNE      |L17.12|
;;;252        }
;;;253        return (crc_hi << 8 | crc_lo);
00002a  ea432005          ORR      r0,r3,r5,LSL #8
;;;254    }
00002e  bd70              POP      {r4-r6,pc}
;;;255    
                          ENDP

                  |L17.48|
                          DCD      table_crc_hi
                  |L17.52|
                          DCD      table_crc_lo

                          AREA ||i.getCRC8||, CODE, READONLY, ALIGN=1

                  getCRC8 PROC
;;;333    *******************************************************************************/
;;;334    uint8_t getCRC8(uint8_t *pbuf,uint8_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;335    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;336    	uint8_t crccheck=0;
000006  2600              MOVS     r6,#0
;;;337    
;;;338        while(len--) 
000008  e006              B        |L18.24|
                  |L18.10|
;;;339        {
;;;340            crccheck = Caculate_CRC8_Byte(crccheck^*pbuf++);
00000a  f8141b01          LDRB     r1,[r4],#1
00000e  ea810006          EOR      r0,r1,r6
000012  f7fffffe          BL       Caculate_CRC8_Byte
000016  4606              MOV      r6,r0
                  |L18.24|
000018  0028              MOVS     r0,r5                 ;338
00001a  f1a50101          SUB      r1,r5,#1              ;338
00001e  b2cd              UXTB     r5,r1                 ;338
000020  d1f3              BNE      |L18.10|
;;;341        }	
;;;342    	return crccheck;
000022  4630              MOV      r0,r6
;;;343    }
000024  bd70              POP      {r4-r6,pc}
;;;344    
                          ENDP


                          AREA ||i.htons||, CODE, READONLY, ALIGN=1

                  htons PROC
;;;507    */ 
;;;508    uint16_t htons( uint16_t hostshort)	/**< A 16-bit number in host byte order.  */
000000  b500              PUSH     {lr}
;;;509    {
000002  4603              MOV      r3,r0
;;;510    #if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )
;;;511    	return swaps(hostshort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       swaps
;;;512    #else
;;;513    	return hostshort;
;;;514    #endif		
;;;515    }
00000a  bd00              POP      {pc}
;;;516    
                          ENDP


                          AREA ||i.inet_addr_||, CODE, READONLY, ALIGN=2

                  inet_addr_ PROC
;;;457    */
;;;458    void inet_addr_(unsigned char* addr,unsigned char *ip)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;459    {
000004  b088              SUB      sp,sp,#0x20
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;460    	int i;
;;;461    	char taddr[30];
;;;462    	char * nexttok;
;;;463    	char num;
;;;464    	strcpy(taddr,(char *)addr);
00000a  4631              MOV      r1,r6
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       strcpy
;;;465    	
;;;466    	nexttok = taddr;
000012  466c              MOV      r4,sp
;;;467    	for(i = 0; i < 4 ; i++)
000014  2500              MOVS     r5,#0
000016  e01b              B        |L20.80|
                  |L20.24|
;;;468    	{
;;;469    		nexttok = strtok(nexttok,".");
000018  a110              ADR      r1,|L20.92|
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       strtok
000020  4604              MOV      r4,r0
;;;470    		if(nexttok[0] == '0' && nexttok[1] == 'x') num = atoi16(nexttok+2,0x10);
000022  7820              LDRB     r0,[r4,#0]
000024  2830              CMP      r0,#0x30
000026  d109              BNE      |L20.60|
000028  7860              LDRB     r0,[r4,#1]
00002a  2878              CMP      r0,#0x78
00002c  d106              BNE      |L20.60|
00002e  2110              MOVS     r1,#0x10
000030  1ca0              ADDS     r0,r4,#2
000032  f7fffffe          BL       atoi16
000036  f00008ff          AND      r8,r0,#0xff
00003a  e005              B        |L20.72|
                  |L20.60|
;;;471    		else num = atoi16(nexttok,10);
00003c  210a              MOVS     r1,#0xa
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       atoi16
000044  f00008ff          AND      r8,r0,#0xff
                  |L20.72|
;;;472    		
;;;473    		ip[i] = num;
000048  f8078005          STRB     r8,[r7,r5]
;;;474    		nexttok = NULL;
00004c  2400              MOVS     r4,#0
00004e  1c6d              ADDS     r5,r5,#1              ;467
                  |L20.80|
000050  2d04              CMP      r5,#4                 ;467
000052  dbe1              BLT      |L20.24|
;;;475    	}
;;;476    }	
000054  b008              ADD      sp,sp,#0x20
000056  e8bd81f0          POP      {r4-r8,pc}
;;;477    /**
                          ENDP

00005a  0000              DCW      0x0000
                  |L20.92|
00005c  2e00              DCB      ".",0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.mid||, CODE, READONLY, ALIGN=1

                  mid PROC
;;;425    */
;;;426    void mid(char* src, char* s1, char* s2, char* sub)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;427    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;428    	char* sub1;
;;;429    	char* sub2;
;;;430    	unsigned short n;
;;;431    
;;;432      sub1=strstr(src,s1);
00000c  4631              MOV      r1,r6
00000e  4648              MOV      r0,r9
000010  f7fffffe          BL       strstr
000014  4604              MOV      r4,r0
;;;433      sub1+=strlen(s1);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       strlen
00001c  4404              ADD      r4,r4,r0
;;;434      sub2=strstr(sub1,s2);
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       strstr
000026  4682              MOV      r10,r0
;;;435      n=sub2-sub1;
000028  ebaa0004          SUB      r0,r10,r4
00002c  fa1ff880          UXTH     r8,r0
;;;436      strncpy(sub,sub1,n);
000030  4642              MOV      r2,r8
000032  4621              MOV      r1,r4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       strncpy
;;;437      sub[n]=0;
00003a  2000              MOVS     r0,#0
00003c  f8050008          STRB     r0,[r5,r8]
;;;438    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;439    
                          ENDP


                          AREA ||i.ntohs||, CODE, READONLY, ALIGN=1

                  ntohs PROC
;;;521    */ 
;;;522    unsigned long ntohs(unsigned short netshort)	/**< netshort - network odering 16bit value */	
000000  b510              PUSH     {r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524    #if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )	
;;;525    	return htons(netshort);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       htons
;;;526    #else
;;;527    	return netshort;
;;;528    #endif		
;;;529    }
00000a  bd10              POP      {r4,pc}
;;;530    
                          ENDP


                          AREA ||i.replacetochar||, CODE, READONLY, ALIGN=1

                  replacetochar PROC
;;;481    */
;;;482    void replacetochar(char * str,	char oldchar,char newchar	)
000000  b510              PUSH     {r4,lr}
;;;483    {
000002  460b              MOV      r3,r1
;;;484      int x;
;;;485      for (x = 0; str[x]; x++) 
000004  2100              MOVS     r1,#0
000006  e004              B        |L23.18|
                  |L23.8|
;;;486        if (str[x] == oldchar) str[x] = newchar;	
000008  5c44              LDRB     r4,[r0,r1]
00000a  429c              CMP      r4,r3
00000c  d100              BNE      |L23.16|
00000e  5442              STRB     r2,[r0,r1]
                  |L23.16|
000010  1c49              ADDS     r1,r1,#1              ;485
                  |L23.18|
000012  5c44              LDRB     r4,[r0,r1]            ;485
000014  2c00              CMP      r4,#0                 ;485
000016  d1f7              BNE      |L23.8|
;;;487    }
000018  bd10              POP      {r4,pc}
;;;488    
                          ENDP


                          AREA ||i.swaps||, CODE, READONLY, ALIGN=1

                  swaps PROC
;;;495    */
;;;496    uint16_t swaps(uint16_t i)
000000  4601              MOV      r1,r0
;;;497    {
;;;498      uint16_t ret=0;
000002  2000              MOVS     r0,#0
;;;499      ret = (i & 0xFF) << 8;
000004  060a              LSLS     r2,r1,#24
000006  0c10              LSRS     r0,r2,#16
;;;500      ret |= ((i >> 8)& 0xFF);
000008  ea402011          ORR      r0,r0,r1,LSR #8
;;;501      return ret;	
;;;502    }
00000c  4770              BX       lr
;;;503    /**
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ChipUniqueID
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  DataStr
000000  4a756c20          DCB      0x4a,0x75,0x6c,0x20
000004  33312032          DCB      0x33,0x31,0x20,0x32
000008  30313700          DCB      0x30,0x31,0x37,0x00
                  TimeStr
00000c  31353a35          DCB      0x31,0x35,0x3a,0x35
000010  373a3330          DCB      0x37,0x3a,0x33,0x30
000014  00                DCB      0x00
                  table_crc_hi
000015  00c181            DCB      0x00,0xc1,0x81
000018  4001c080          DCB      0x40,0x01,0xc0,0x80
00001c  4101c080          DCB      0x41,0x01,0xc0,0x80
000020  4100c181          DCB      0x41,0x00,0xc1,0x81
000024  4001c080          DCB      0x40,0x01,0xc0,0x80
000028  4100c181          DCB      0x41,0x00,0xc1,0x81
00002c  4000c181          DCB      0x40,0x00,0xc1,0x81
000030  4001c080          DCB      0x40,0x01,0xc0,0x80
000034  4101c080          DCB      0x41,0x01,0xc0,0x80
000038  4100c181          DCB      0x41,0x00,0xc1,0x81
00003c  4000c181          DCB      0x40,0x00,0xc1,0x81
000040  4001c080          DCB      0x40,0x01,0xc0,0x80
000044  4100c181          DCB      0x41,0x00,0xc1,0x81
000048  4001c080          DCB      0x40,0x01,0xc0,0x80
00004c  4101c080          DCB      0x41,0x01,0xc0,0x80
000050  4100c181          DCB      0x41,0x00,0xc1,0x81
000054  4001c080          DCB      0x40,0x01,0xc0,0x80
000058  4100c181          DCB      0x41,0x00,0xc1,0x81
00005c  4000c181          DCB      0x40,0x00,0xc1,0x81
000060  4001c080          DCB      0x40,0x01,0xc0,0x80
000064  4100c181          DCB      0x41,0x00,0xc1,0x81
000068  4001c080          DCB      0x40,0x01,0xc0,0x80
00006c  4101c080          DCB      0x41,0x01,0xc0,0x80
000070  4100c181          DCB      0x41,0x00,0xc1,0x81
000074  4000c181          DCB      0x40,0x00,0xc1,0x81
000078  4001c080          DCB      0x40,0x01,0xc0,0x80
00007c  4101c080          DCB      0x41,0x01,0xc0,0x80
000080  4100c181          DCB      0x41,0x00,0xc1,0x81
000084  4001c080          DCB      0x40,0x01,0xc0,0x80
000088  4100c181          DCB      0x41,0x00,0xc1,0x81
00008c  4000c181          DCB      0x40,0x00,0xc1,0x81
000090  4001c080          DCB      0x40,0x01,0xc0,0x80
000094  4101c080          DCB      0x41,0x01,0xc0,0x80
000098  4100c181          DCB      0x41,0x00,0xc1,0x81
00009c  4000c181          DCB      0x40,0x00,0xc1,0x81
0000a0  4001c080          DCB      0x40,0x01,0xc0,0x80
0000a4  4100c181          DCB      0x41,0x00,0xc1,0x81
0000a8  4001c080          DCB      0x40,0x01,0xc0,0x80
0000ac  4101c080          DCB      0x41,0x01,0xc0,0x80
0000b0  4100c181          DCB      0x41,0x00,0xc1,0x81
0000b4  4000c181          DCB      0x40,0x00,0xc1,0x81
0000b8  4001c080          DCB      0x40,0x01,0xc0,0x80
0000bc  4101c080          DCB      0x41,0x01,0xc0,0x80
0000c0  4100c181          DCB      0x41,0x00,0xc1,0x81
0000c4  4001c080          DCB      0x40,0x01,0xc0,0x80
0000c8  4100c181          DCB      0x41,0x00,0xc1,0x81
0000cc  4000c181          DCB      0x40,0x00,0xc1,0x81
0000d0  4001c080          DCB      0x40,0x01,0xc0,0x80
0000d4  4100c181          DCB      0x41,0x00,0xc1,0x81
0000d8  4001c080          DCB      0x40,0x01,0xc0,0x80
0000dc  4101c080          DCB      0x41,0x01,0xc0,0x80
0000e0  4100c181          DCB      0x41,0x00,0xc1,0x81
0000e4  4001c080          DCB      0x40,0x01,0xc0,0x80
0000e8  4100c181          DCB      0x41,0x00,0xc1,0x81
0000ec  4000c181          DCB      0x40,0x00,0xc1,0x81
0000f0  4001c080          DCB      0x40,0x01,0xc0,0x80
0000f4  4101c080          DCB      0x41,0x01,0xc0,0x80
0000f8  4100c181          DCB      0x41,0x00,0xc1,0x81
0000fc  4000c181          DCB      0x40,0x00,0xc1,0x81
000100  4001c080          DCB      0x40,0x01,0xc0,0x80
000104  4100c181          DCB      0x41,0x00,0xc1,0x81
000108  4001c080          DCB      0x40,0x01,0xc0,0x80
00010c  4101c080          DCB      0x41,0x01,0xc0,0x80
000110  4100c181          DCB      0x41,0x00,0xc1,0x81
000114  40                DCB      0x40
                  table_crc_lo
000115  00c0c1            DCB      0x00,0xc0,0xc1
000118  01c30302          DCB      0x01,0xc3,0x03,0x02
00011c  c2c60607          DCB      0xc2,0xc6,0x06,0x07
000120  c705c5c4          DCB      0xc7,0x05,0xc5,0xc4
000124  04cc0c0d          DCB      0x04,0xcc,0x0c,0x0d
000128  cd0fcfce          DCB      0xcd,0x0f,0xcf,0xce
00012c  0e0acacb          DCB      0x0e,0x0a,0xca,0xcb
000130  0bc90908          DCB      0x0b,0xc9,0x09,0x08
000134  c8d81819          DCB      0xc8,0xd8,0x18,0x19
000138  d91bdbda          DCB      0xd9,0x1b,0xdb,0xda
00013c  1a1ededf          DCB      0x1a,0x1e,0xde,0xdf
000140  1fdd1d1c          DCB      0x1f,0xdd,0x1d,0x1c
000144  dc14d4d5          DCB      0xdc,0x14,0xd4,0xd5
000148  15d71716          DCB      0x15,0xd7,0x17,0x16
00014c  d6d21213          DCB      0xd6,0xd2,0x12,0x13
000150  d311d1d0          DCB      0xd3,0x11,0xd1,0xd0
000154  10f03031          DCB      0x10,0xf0,0x30,0x31
000158  f133f3f2          DCB      0xf1,0x33,0xf3,0xf2
00015c  3236f6f7          DCB      0x32,0x36,0xf6,0xf7
000160  37f53534          DCB      0x37,0xf5,0x35,0x34
000164  f43cfcfd          DCB      0xf4,0x3c,0xfc,0xfd
000168  3dff3f3e          DCB      0x3d,0xff,0x3f,0x3e
00016c  fefa3a3b          DCB      0xfe,0xfa,0x3a,0x3b
000170  fb39f9f8          DCB      0xfb,0x39,0xf9,0xf8
000174  3828e8e9          DCB      0x38,0x28,0xe8,0xe9
000178  29eb2b2a          DCB      0x29,0xeb,0x2b,0x2a
00017c  eaee2e2f          DCB      0xea,0xee,0x2e,0x2f
000180  ef2dedec          DCB      0xef,0x2d,0xed,0xec
000184  2ce42425          DCB      0x2c,0xe4,0x24,0x25
000188  e527e7e6          DCB      0xe5,0x27,0xe7,0xe6
00018c  2622e2e3          DCB      0x26,0x22,0xe2,0xe3
000190  23e12120          DCB      0x23,0xe1,0x21,0x20
000194  e0a06061          DCB      0xe0,0xa0,0x60,0x61
000198  a163a3a2          DCB      0xa1,0x63,0xa3,0xa2
00019c  6266a6a7          DCB      0x62,0x66,0xa6,0xa7
0001a0  67a56564          DCB      0x67,0xa5,0x65,0x64
0001a4  a46cacad          DCB      0xa4,0x6c,0xac,0xad
0001a8  6daf6f6e          DCB      0x6d,0xaf,0x6f,0x6e
0001ac  aeaa6a6b          DCB      0xae,0xaa,0x6a,0x6b
0001b0  ab69a9a8          DCB      0xab,0x69,0xa9,0xa8
0001b4  6878b8b9          DCB      0x68,0x78,0xb8,0xb9
0001b8  79bb7b7a          DCB      0x79,0xbb,0x7b,0x7a
0001bc  babe7e7f          DCB      0xba,0xbe,0x7e,0x7f
0001c0  bf7dbdbc          DCB      0xbf,0x7d,0xbd,0xbc
0001c4  7cb47475          DCB      0x7c,0xb4,0x74,0x75
0001c8  b577b7b6          DCB      0xb5,0x77,0xb7,0xb6
0001cc  7672b2b3          DCB      0x76,0x72,0xb2,0xb3
0001d0  73b17170          DCB      0x73,0xb1,0x71,0x70
0001d4  b0509091          DCB      0xb0,0x50,0x90,0x91
0001d8  51935352          DCB      0x51,0x93,0x53,0x52
0001dc  92965657          DCB      0x92,0x96,0x56,0x57
0001e0  97559594          DCB      0x97,0x55,0x95,0x94
0001e4  549c5c5d          DCB      0x54,0x9c,0x5c,0x5d
0001e8  9d5f9f9e          DCB      0x9d,0x5f,0x9f,0x9e
0001ec  5e5a9a9b          DCB      0x5e,0x5a,0x9a,0x9b
0001f0  5b995958          DCB      0x5b,0x99,0x59,0x58
0001f4  98884849          DCB      0x98,0x88,0x48,0x49
0001f8  894b8b8a          DCB      0x89,0x4b,0x8b,0x8a
0001fc  4a4e8e8f          DCB      0x4a,0x4e,0x8e,0x8f
000200  4f8d4d4c          DCB      0x4f,0x8d,0x4d,0x4c
000204  8c448485          DCB      0x8c,0x44,0x84,0x85
000208  45874746          DCB      0x45,0x87,0x47,0x46
00020c  86824243          DCB      0x86,0x82,0x42,0x43
000210  83418180          DCB      0x83,0x41,0x81,0x80
000214  40                DCB      0x40

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
                  STM32_FLASH_SIZE
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\User\\Src\\Utility.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_Utility_c_DataStr____REV16|
#line 129 "..\\Libraries\\ST_Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_Utility_c_DataStr____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_Utility_c_DataStr____REVSH|
#line 144
|__asm___9_Utility_c_DataStr____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_Utility_c_DataStr____RRX|
#line 300
|__asm___9_Utility_c_DataStr____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
